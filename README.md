# CJSBinder

**CJSBinder** is a C-to-JavaScript glue code generator implemented in Python with Clang. Given C class declaration, **CJSBinder** can generate glue code to wrap the class into the JavaScript environment. A configuration file can be given to adjust the style of generated glue code.    
**CJSBinder** can be runned with the following example command:

---
     python3 generator.py -P configuration/node.js/AsynWrap.json -H input/node.js/AsynWrap.h -o output/node/AsynWrap.cpp
---

-P:&ensp;A configuration file containing a template block and a parameter block.  
-H:&ensp;The declaration of the existing C class.       
-o:&ensp;The file name of output(generated code).    

# Experiment
The experiments are conducted on a 3.20GHZ AMD Ryzen 7 5800H processor with 16 GB of 3200 MHz DDR4 running Linux 18.04 OS. CJSBinder is run with **Python 3.7.5** and **Clang 8.0.0**. **Swig** is the newest version 4.1.1.

## Correctness and Efficiency

We select 686 problem solutions coding in C from datasets of TransCoder. They are appended with 10 tests. The outputs of the tests (i.e., ground truths) are in **experiment/correctness_efficiency/groundtruth/outpus**.

We use **CJSBinder** and **Swig** to generate glue code to wrap the C solutions. Then we use the same inputs but calling in JavaScript. We compare the outputs of glue code with ground truths.

Glue code uses V8 raw APIs. V8 headers and static library are given in **experiment/correctness_efficiency/v8** (version 8.0).

### CJSBinder
In **CJSBinder**, We use only one configuration file **experiment/correctness_efficiency/cjsbinder/CQuesConfig.json** to generate all glue code. Moreover, we use fake headers to accelerate Pyclang. Fake headers only contains simple declaration of std::vector and std::string to indicate Pyclang that they are types.

V8 engine with wrapper class embedded can be compiled by the following command:

---
     g++ -std=c++11 -I v8/ -I v8/include -o ENGINE gluecode.cpp v8/libv8.a -lpthread
---

Then outputs can be got by:

---
     ./ENGINE test.js
---

### Swig

Glue code (named Wrap.cpp in our experiments) is generated by **Swig** using commands like following:

---
     swig -javascript -c++ -v8 -o PROBLEM_NAME/Wrap.cpp PROBLEM_NAME/CQues.i
---

Noticed that glue code generated by Swig has no main function. We manually implement a main function in **experiment/correctness_efficiency/swig/swigmain.cpp** for all tasks. Thus V8 engine is compiled by:

---
     g++ -std=c++11 -I v8/ -I v8/include -o ENGINE Wrap.cpp swigmain.cpp v8/libv8.a -lpthread
---

Then outputs can be got by the same way to **CJSBinder**

## Usefulness
We choose real class wrapping examples from open source projects(Node.js, graaljs, nodegui and PuerTS) with little adaptation as our generation targets (benchmarks). We use **CJSBinder** and **Swig** to generate glue codes and compare them with target codes.  

### CJSBinder
In CJSBinder, We customize a configuration file for every benchmark. For example, if the target is **targetcode/graaljs/Blob.cpp**, the corresponding glue code can be generated by the configuration file with the same name, just like:

---
     python3 generator.py -P configuration/graaljs/Blob.json -H input/graaljs/Blob.h -o output/graaljs/Blob.cpp
---

### Swig
Glue code is generated by Swig using commands like following:

---
     swig -javascript -c++ -v8 -o output/graaljs/Blob.cpp input/graaljs/Blob.i
---
